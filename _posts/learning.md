##Mysql
尚硅谷 资料在D:\Learning\学习资料\mysql
https://www.bilibili.com/video/BV12b411K7Zu?p=156

##java数据结构与java算法
尚硅谷 资料在D:\Learning\学习资料\数据结构资料
https://www.bilibili.com/video/BV1E4411H73v?p=1

##javaweb
https://www.bilibili.com/video/BV1Yz411B7Pk?p=10&spm_id_from=pageDriver
复习html+css+js
学习互联网通信流程等一些基础知识
servlet+jsp

##maven3.6.1
https://www.bilibili.com/video/BV1Fz4y167p5?p=10 

##JDK动态代理（理解）：基于反射机制
动力节点 资料D:\Learning\学习资料\SSM框架\05-最新版SSM（IDEA全套）\01-JDK动态代理             
https://www.bilibili.com/video/BV1HZ4y1p7F1      

##Mybatis 数据访问层dao包（XXXDao类）
动力节点 资料D:\Learning\学习资料\SSM框架\05-最新版SSM（IDEA全套）\03-MyBatis          
https://www.bilibili.com/video/BV185411s7Ry?from=search&seid=13192653407365116498

##Spring 业务逻辑层service包（XXXService类）
尚硅谷https://www.bilibili.com/video/BV1Vf4y127N5?p=2&spm_id_from=pageDriver
动力节点https://www.bilibili.com/video/BV1nz4y1d7uy?p=7
动力节点资料D:\Learning\学习资料\SSM框架\05-最新版SSM（IDEA全套）
尚硅谷讲的是spring5框架，动力节点讲的是spring4框架，综合来看
动力节点的教程是通过maven导入依赖的方式创建spring工程的，比较方便，故选择这个

##Spring MVC 界面层controller包（servlet）
动力节点https://www.bilibili.com/video/BV1sk4y167pD/?p=2&spm_id_from=pageDriver
动力节点资料D:\Learning\学习资料\SSM框架\05-最新版SSM（IDEA全套）  

##Ajax 异步的javascript和XML（json）
https://www.bilibili.com/video/BV1Kt411u7BV
动力节点 https://www.bilibili.com/video/BV15k4y167XM?from=search&seid=259794468532943748&spm_id_from=333.337.0.0

##Spring Boot 
有学习资料在D:\Learning\学习资料\springboot资料                      
https://www.bilibili.com/video/BV1gW411W76m?p=8&spm_id_from=pageDriver
尚硅谷  讲源码
https://www.bilibili.com/video/BV19K4y1L7MT?p=31

##redis6
安装redis https://www.iotschool.com/wiki/redis

##Axure
https://www.bilibili.com/video/BV1eA41157sk?p=12

##thingsboard
https://blog.csdn.net/github_35631540/category_11377483.html

##计算机网络
https://www.bilibili.com/video/BV19E411D78Q?p=37

##操作系统
https://www.bilibili.com/video/BV1d4411v7u7?spm_id_from=333.337.search-card.all.click

##恋上数据结构与算法（第一季）
https://www.bilibili.com/video/BV1yP4y147zw?from=search&seid=694799062547809211&spm_id_from=333.337.0.0

###Linux
https://www.bilibili.com/video/BV1dW411M7xL?p=1
安装CentOS 7
https://www.runoob.com/w3cnote/vmware-install-centos7.html

###java设计模式

###kafka


##放假之后至7月4日之前
####javascript+html+css基础学习 使用Sublime Text 
实现web与mysql数据库的交互需要配置IIS+php+apache+mysql环境

##7月4日
mysql 1p-14p

##7月5日
mysql 15p-24p

##7月6日
mysql 25p-45p

##7月7日
mysql 46p-61p

##7月8日
mysql 62p-78p

##7月9日
mysql 79p-90p

##7月10日
####将内网IP映射到外网
	电脑右键-管理-服务和应用程序-IIS-网站-编辑网站绑定
	192.168.184.1:8080
	花生壳-通过http映射-将内网IP映射到外网 http://c3567189p7.qicp.vip
mysql 91p-97p

##7月11日
花生壳
15236292237 dlh0320...
lhdeng dlh0320...
mysql 98p-109p
##7月12日
mysql 110p-120p

##7月13日
mysql 121p-135p

##7月14日
mysql 136p-173p

##7月15日
mysql 174p-178p

##7月16日-7月20日
vue基础学习;复习js;物联网对比ppt

##7月21日
复习js;java数据结构与java算法
1p-10p 稀松数组、队列、循环队列           

##7月22日
java数据结构与java算法 11p-21p 单链表

##7月23日
java数据结构与java算法 22p-23p;
物联网风电机组监控

##7月24-27日
物联网风电机组监控;
visio绘图

##7月28日
创建一个Spring Boot项目;
继续java数据结构与java算法23p-27p 双链表、约瑟夫问题（未看完）

##7月29日
####java数据结构与java算法   
栈、前缀中缀后缀表达式规则、递归问题、            
排序算法介绍和分类          
1. 插入排序        
直接插入排序、希尔排序        
2. 选择排序            
简单选择排序、堆排序       
3. 交换排序           
冒泡排序、快速排序          
4. 归并排序      
5. 基数排序   
算法的时间复杂度计算(时间频度)52p例子 平均时间复杂度与最坏时间复杂度          
算法的空间复杂度
树结构的基础部分       
1. 二叉排序树                   
了解Mybatis                             

##7月30日
maven3.6.1           
1p-10p               
由于刚开始配置maven3.8.1与IDEA2019不兼容浪费了时间，Maven项目与Spring Initializr 项目区别在于Maven需要手动导入依赖，Spring Initializr可以在创建时选择需要的功能而由IDE直接导入依赖                                         
Spring Boot 1p-8p                                
Mybatis 1p-7p

##7月31日
可以通过mybatis框架读取数据库
Mybatis 7p-19p

##8月1日
maven 10p-13p 可以实现不同配置环境（如本地、测试、正式环境）的打包，配置环境里有数据库环境等配置 <profiles>   具体实现可以看12p                 
JDK动态代理 1p-17p完        

##8月2日
mybatis 19p-39p

##8月3日
mybatis 40p-49p 完     
spring 1p-22p

##8月4日
spring 23p-54p            
ioc控制反转 容器  在使用类的上面添加注解或者在xml文件中配置bean标签即可通过IOC创建该类的对象       
aop面向切面编程（aspectj框架） 功能增强     

##8月5日
spring 55p-85p

##8月6日
spring 85p-102p 完 
tomcat配置:  
踩坑记录（使用压缩包解压安装）      
https://blog.csdn.net/qq_44918461/article/details/104319822

1.首先需配置好jdk环境，可通过cmd中的java -version命令查看

2.将下载的zip压缩包解压，记住路径

3.新建CATALINA_HOME系统变量（tomcat路径）与添加Path变量（%CATALINA_HOME%\bin与%CATALINA_HOME%\lib（后来删除好像也没啥事））

4.解压后在cmd进入到安装路径的bin目录下，执行service.bat install 提示The service “tomcat9” has been installed ,则表示成功。

验证1：在tomcat\bin目录 ,双击tomcat9W.exe,在弹出的图形界面中 ,点击start ,运行tomcat ,浏览器输入localhost:8080 ,访问!!!
验证2：在tomcat\bin目录 ,双击tomcat9.exe，弹出后没有闪退，不要关掉!!!访问localhost:8080

我的问题：刚开始，访问不了8080，一顿操作后打开tomcat9.exe还会出现闪退

解决方法：
闪退问题：重启之后又添加了ClassPath变量（;%CATALINA_HOME%\lib\servlet-api.jar ），故不知是哪种方法解决了这个问题（我认为是重启，因为后来删除了ClassPath变量也没事）  
HTTP Error 400. The request hostname is invalid：tomcat安装文件目录conf下的serve.xml中的端口设置问题，设为8080可能是因为端口占用，使用8081端口没有这个问题

IDEA通过jsp提交表单数据的乱码问题
在web.xml中添加如下即可
    <filter>
        <filter-name>encoding</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <!-- 初始化 参数 设置编码是UTF-8 -->
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
    </filter>
    <!-- 设置过滤对象 -->
    <filter-mapping>
        <filter-name>encoding</filter-name>
        <!--对所有的都过滤,并走 过滤器 名称是encoding的所对应的类-->
        <url-pattern>/*</url-pattern>
    </filter-mapping>

SpringMVC 1p-2p 

##8月7日
SpringMVC 2p-26p 39p-49p
总结遇到的问题：
1.resources文件夹没有标记为资源文件夹
2.index.jsp放在了WEB-INF目录下，该目录下的.jsp用户是访问不了的

##8月8日
SpringMVC 49p-53p（SSM整合） 54p-56p(转发、重定向)
问题：
1.重新打开项目时@Resource报红
解决：在Project Structure中的Dependencies栏下Module SDK没有选择对应的1.8
2.网页访问500空指针异常
解决：Controller文件中@Resource注解没加

SSM总结：
jsp页面提交数据到XXX.do--Controller类(在dispatcherServlet中央调度器(MVC容器))，通过@RequestMapping("XXX.do")定位到方法--方法中调用相应的Service对象方法--Service对象方法调用对应的Dao类接口(Service类、Dao类都在spring容器内)--Dao类接口在容器中实现SqlSession.getMapper(Dao.class)访问数据库(即Mybatis)
MVC容器是spring容器的子容器

##8月9日
servlet 85p
Axure  登录页面

#8月10日
Axure  设计页面

#8月11日
Axure页面参考太少，需要多做调研再做
大话数据结构  看前两章

#8月12日
Axure画页面
大话数据结构  看到p54
servlet 86p-91p

#8月13日
Axure画页面 分析流程

#8月14日
Axure画页面 分析流程
互联网通信流程

#8月15日
调研页面功能，总结功能架构

#8月16日
用visio画业务流程

#8月17日
画业务流程

#8月18日
用泳道图画业务流程
大话数据结构  看到p60

#8月19日
画安装业务流程
复习html完毕

#8月20日
画安装业务流程
复习css完毕
servlet 92p-97p
###抽象类作用：
降低接口实现类对接口实现过程难度
将接口中不需要使用抽象方法交给抽象类进行完成
这样接口实现类只需要对接口需要方法进行重写

#8月21日
画业务流程
servlet 97p
打开windows锁屏壁纸：C:\Users\了一\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets

#8月22日
画业务流程
servlet98p-100p

问题：

浏览器以get方式发送请求，请求参数保存在【请求头】，在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求头二进制内容由Tomcat负责解码，Tomcat9.0默认使用【utf-8】字符集，可以解释一切国家文字

浏览器以post方式发送请求，请求参数保存在【请求体】，在Http请求协议包到达Http服务器之后，第一件事就是进行解码，请求体二进制内容由当前请求对象（request）负责解码，request默认使用【ISO-8859-1】字符集，一个东欧语系字符集，此时如果请求体参数内容是中文，将无法解码只能得到乱码

解决方案：

在post请求方式下，在读取请求体内容之前，应该通知请求对象使用utf-8字符集对请求体内容进行一次重新解码
request.setCharacterEncoding("utf-8");

###HttpServletResponse接口
主要功能：
1.将执行结果以二进制形式写入到【响应体】
2.设置响应头中【content-type】属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字、图片、视频、命令】
3.设置响应头中的【location】属性，将一个请求地址赋值给location，从而控制浏览器向指定服务器发送请求
###HttpServletRequest接口
主要功能：
1.可以读取Http请求协议包中【请求行】信息
2.可以读取保存在Http请求协议包中【请求头】或者【请求体】中请求参数信息
3.可以代替浏览器向Http服务器申请资源文件调用 

#8月23日
画业务流程
servlet 100p-101p

踩坑记录：
手动在IDEA中添加mysql的jar包需要右击Add as Library，否则连不到数据库

问题：
HttpServlet类在何时调用service方法

service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。

每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。

#8月24日
画业务流程
servlet 102p-110p

#8月25日
servlet 111p-120p

###多个Servlet之间调用规则

1.重定向解决方案
	response.sendRedirect("/网站名/资源文件名");
2.请求转发解决方案
	//通过当前请求对象生成资源文件申请报告对象
	ResquestDiapatcher report = request.getRequestDispatcher("/资源文件名");**不要写网站名**
	//将报告对象发送给Tomcat
	report.forward(当前请求对象，当前响应对象);

###Servlet规范中提供的四种数据共享方案

1.ServletContext接口【全局作用域对象】

	//放数据
	ServletContext application = request.getServletContext();
	application.setAttribute("key1",数据);
	
	//取数据
	ServletContext application = request.getServletContext();
	Object 数据 = application.getAttribute("key1");

2.Cookie类

	OneServlet类的doGet方法中:
	//1.创建一个cookie对象，保存共享数据（当前用户数据）
	Cookie card = new Cookie("key1"，"abc");
	Cookie card1 = new Cookie("key2"，"dlh");
	**cookie相当于一个map
	**一个cookie中只能存放一个键值对
	**这个键值对的key和value只能是String
	**键值对中的key不能是中文

	//2.将cookie写入到响应头，交给浏览器
	resp.addCookie(card);
	resp.addCookie(card1);


	TwoServlet类中的doGet方法中:
	//1.调用请求对象从请求头得到浏览器返回的Cookie
	Cookie cookieArray[] = request.getCookie();

	//2.循环遍历数据得到每一个cookie的key和value
	for(Cookie card:cookieArray){
		String key = card.getName();
		String value = card.getValue();
	}

3.HttpSession接口【会话作用域对象】

	OneServlet类的doGet方法中:
	//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜
	HttpSession session = request.getSession();
	//2.将数据添加到用户私人储物柜
	session.setAttribute("key1",共享数据);

	TwoServlet类中的doGet方法中:
	//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜
	HttpSession session = request.getSession();
	//2.从会话作用域对象得到Oneservlet提供的共享数据
	Object 共享数据 = session.getAttribute("key1");

4.HttpServletRequest接口【请求作用域对象】

	OneServlet类的doGet方法中:
	//1.将数据添加到【请求作用域对象】中的Attribute属性
	request.setAttribute("key1",数据);
	//2.向Tomcat申请调用TwoServlet
	request.getRequestDispatcher("/two").forward(request,response);

	TwoServlet类中的doGet方法中:
	Object 共享数据 = request.getAttribute("key1");


#8月26日
servlet 120p-122p

#8月27日
servlet 122p

#8月28日
servlet 123p-126p

#8月29日
servlet 127p-130p

#8月30日
servlet 131p-132p servlet完结
jsp 133p-134p

#8月31日
jsp 135p-139p 142p-148p

###jsp与servlet的区别
jsp代替的是servlet
https://blog.csdn.net/King_wq_2020/article/details/118631218

###Http服务器调用JSP文件步骤

1.Http服务器将JSP文件内容【编辑】为一个Servlet接口实现类（.java）
2.Http服务器将Servlet接口实现类【编译】为class文件（.class）
3.Http服务器负责创建这个class的实例对象，这个实例对象就是Servlet实例对象
4.Http服务器通过Servlet实例对象调用_jspService方法，将jsp文件内容写入到响应体

###Http服务器【编辑】与【编译】jsp文件位置

在网站的【work】文件夹中

C:\Users\了一\.IntelliJIdea2019.3\system\tomcat\Tomcat_9_0_50_Servlet_3\work\Catalina\localhost\ROOT\org\apache\jsp

###jsp中有内置的对象如application、session、out、request、response等

###EL表达式（没有提供遍历集合的方法，JSTL可以有效弥补）

1.命令格式：${作用域对象别名.共享数据}
2.命令作用：
	1）EL表达式是EL工具包提供的一种特殊命令格式【表达式命令格式】
	2）EL表达式在JSP文件上使用
	3）负责在JSP文件上从作用域对象读取指定的共享数据并输出到响应体

###多线程三大特征

原子性、可见性、有序性

#9月3日
jsp 149p-152p jsp完结

#9月5日
Ajax 1p-15p

###xml是一种数据格式

#9月6日
Ajax 16p-30p 完结
json数据描述格式 184p

#9月7日
json 184p-185p

#9月8日
大话数据结构  看到p127 链表、栈、队列；跳过串

###链表的头结点与头指针
	链表中第一个结点的【存储位置】叫做头指针，头指针指向第一个结点，若链表有头结点，则头指针指向头结点，头指针是链表的必要元素；
	有时会在单链表的第一个结点前附设一个头结点，其数据域可以不存储任何信息，指针域存储指向第一个结点的指针，头结点不一定是链表必须要素。

###头结点的作用
	方便在第1个位置进行插入、删除操作时同其他位置一样。加了头结点之后，插入、删除都是在后继指针next上进行操作，不用动头指针；若不加头结点的话，在第1个位置插入或者删除第1个元素时，需要动的是头指针。

###对于链栈来说不需要头结点

#9月9日
js 156p（互联网流程最终版讲解）-
大话数据结构 看到p170

#9月10日
大话数据结构 看到p296 跳过图
js 157p-169p

###顺序存储结构一般只用于完全二叉树，否则可能会对存储空间造成浪费，如右斜树

###js数据类型number、string、boolean、object、function

###js中所有通过【构造函数】生成的对象都是object类型；所有函数都是function类型

###js中所有变量在没有赋值时，其默认值都是undefined，undefined不是一种数据类型；js中当一个对象赋值为null时，表示对象引用了一个【空内存】，这个空内存既不能存数据也不能读取数据，此时这个对象的数据类型依然认为是object类型；js中当一个变量赋值为NaN，表示变量接收了一个【非法数字】如abc123，此时这个变量的数据类型依然认为是number类型;js中当一个变量赋值为infinity，表示变量接收了一个【无穷大数字】，此时这个变量的数据类型依然认为是number

###浏览器在接收到html文件后，将html文件标签加载到浏览器缓存中，每当加载一个html标签的时候，自动为这个标签生成一个实例对象，这个实例对象就是DOM对象（Document Object Model文档模型对象），如table_dom,tr_dom,td_domtext_dom；在浏览器将网页中所有标签加载完毕后，在内存中将使用【树形结构】存储这些DOM对象，在树形结构生成完毕后由浏览器生成一个document对象管理这棵树（DOM树），浏览器运行期间只会生成一个document对象

#9月11日
js 170p-184p js完结

###js中【普通函数】与【构造函数】区分
	函数没有调用之前，无法区分函数身份，只能根据函数调用形式区分；判断普通函数，var num = 函数对象名()；判断构造函数，var num = new 函数对象名()；返回值：普通函数运行后需要通过return将执行结果返回，构造函数运行后，直接返回一个object类型对象，此时函数return相当于无效

###js中this指向与java中this指向完全一致
	1.在构造函数，this指向当前构造函数生成的object类型对象
	2.在普通函数，this指向调用当前函数的实例对象

###js模拟HashMap类型对象
	function HashMap(){
	        var obj = new Object();
	        this.put = function(key, value){
	                obj[key] = value;
					//this[key] = value;//使用this的话可以不用创建object对象
	        }
	        this.get = function(key){
	                return obj[key];
					//return this[key];
	        }
	}
	
	var map = new HashMap();
	map.put("key1",100);
	map.put("key2",200);
	window.alert(map.get("key1") + "   " + map.get("key2"));

#9月12日
json185p-187p
MVC、业务、互联网通信开发过程188p-193p javaweb完结
大话数据结构 看到p300

###开发人员习惯将由json生成object类型对象称为【json对象】

###js中得到object类型对象方式
	1.有构造函数生成的对象 var obj = new Object();    var date = new Date();
	2.由json数据描述格式生成的对象 var obj = {"属性名1":值1,"属性名2":值2};  var obj = {};

###MVC
	C，controller object 控制层对象（servlet对象）
	M，model object 业务模型对象（Service对象）
	V，view object 视图层对象（jsp or HttpServletResponse）

#9月13-15日
上课、力扣

#9月15日
部署thingsboard
通过git拉取源码git clone https://github.com/thingsboard/thingsboard，若有问题，将https改为git

#9月16日
###用户变量与系统变量
	普通变量的优先级是用户变量大于系统变量，对于Path变量，是系统变量大于用户变量

#9月17日
画小程序界面

#9月18日
复习数值分析

###安装docker出现的问题
启动时出现install WSL2 kernel update的情况（https://blog.csdn.net/LeungSr/article/details/117900614）

WSL Microsoft .NET Framework
应用程序中发生了未经处理的异常。如果单击“继续”，应用程序将忽略此错误并尝试继续。如果单击“退出”，应用程序将立即关闭。
引发类型为:Docker. ApiServices. WSL2. WslKernelUpdateNotIns talledException的异常。

解决：
	1.检查win10版本，这里的话检查的版本号比1909高就行
	2.在浏览器中打开网站https://czf-net.xyz/res，点开链接后，有一个叫wsl.msi的文件，我们将其下载下来安装 (安装过程无脑下一步就ok) ，docker就可以正常启动了

###在win10上使用Docker部署thingsboard
安装步骤
	https://blog.csdn.net/keyiis_sh/article/details/118186862?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-4.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-4.searchformbaiduhighlight

	1. win10安装wsl2
	2. 安装docker desktop,下载后直接安装即可
	3. 拉取ThingsBoard官方镜像 
	   打开powershell运行如下命令，等待命令执行完毕
	   docker pull thingsboard/tb-postgres
	4. 使用Docker Compose部署容器
	   新建一个文件夹，比如我在D盘根目录下新建“thingsboard”目录，然后在这个目录下创建文件 “docker-compose.yml”，文件内容如下：
	   version: '2.2'
	   services:
	     mytb:
	       restart: always
	       image: "thingsboard/tb-postgres"
	       ports:
	         # 映射80端口，这样在win10浏览器可用http://localhost直接访问thingsboard
	         - "801:9090"
	         - "1883:1883"
	         - "5683:5683/udp"
	         # 映射postgres端口到win10,便于用pgadmin管理数据库
	         - "5432:5432"
	       environment:
	         # 使用内存进行消息处理
	         TB_QUEUE_TYPE: in-memory
	       volumes:
	         # 将postgres的数据目录映射到win10的本地目录d:\thinsboard\data
	         - /D/thinsboard/data:/data
	         # 将thingsboard日志目录映射到win10的本地目录d:\thinsboard\log
	         - /D/thinsboard/log:/var/log/thingsboard
	     
	   在d:\thingsboard新建上面文件用到的 data 和 log目录。然后在d:\thingsboard下打开powershell，依次运行下面两条命令

	   docker-compose pull
	   docker-compose up

	   等待窗口没有输出了，然后用浏览器访问http://localhost 看到thingsboard的界面即代表部署好了，提醒下这个是免费的社区版，功能没有收费的专业版多，比如只支持mqtt和coap，像modbus/opcua等都不支持，具体可去官网查询。

###部署thingsboard时出现的错误
docker-compose up出现错误（80端口占用）

	>> docker-compose up
	Starting thingsboard_mytb_1 ... error
	
	ERROR: for thingsboard_mytb_1  Cannot start service mytb: Ports are not available: listen tcp 0.0.0.0:80: bind: An attempt was made to access a socket in a way forbidden by its access permissions.
	
	ERROR: for mytb  Cannot start service mytb: Ports are not available: listen tcp 0.0.0.0:80: bind: An attempt was made to access a socket in a way forbidden by its access permissions.
	ERROR: Encountered errors while bringing up the project.
	PS E:\Project\IDEA\thingsboard>

解决：
	修改yml文件中的端口80为801

###thingsboard的默认的账号和密码是
	账号：sysadmin@thingsboard.org
	密码：sysadmin

#9月19日
###win10上的docker怎么设置开机不要自动启动
	每次win10开机都自动启动docker，感觉很耗资源，docker只是有时开发时需要用到，
	在docker的setting上的Start Docker Desktop when you log in取消了也没有效果
	
	在任务管理器中的启动选项中勾掉docker就可以了

#9月22日
###pgAdmin连接docker中thingboard镜像中的postgres数据库
	1.连接之前设置E:\Project\thingsboard\data\db中的两个文件：
	修改postgresql.conf文件中的listen_addresses = '*'
	pg_hba.conf文件中增加
	# 手工添加允许远程访问
	host    all             all             0.0.0.0/0               password
	2.pgAdmin中创建Server
	General中Name为thingsboard
	默认的数据库名postgres用户名thingsboard密码thingsboard
	Hostname/address为127.0.0.1 
	Port为5432

###postgres相关命令
列出PostgreSQL中的所有用户：在psql界面中，运行\du命令
列出数据库名  \l


#9月24日
###thingsboard发送邮件功能测试成功
https://blog.csdn.net/NightHulk/article/details/106379039
1.启用网易邮箱的IMAP/SMTP服务，并获取授权密码OGELPMHLFNWLSXDO
2.在系统管理员中发送邮件功能处的具体设置
	ThingsBoard <lhdeng320@163.com>
	SMTP
	smtp.163.com       25
	10000
	不启用TLS 不启用代理
	lhdeng320@163.com
	授权密码
3.发送测试邮件
邮件从网易邮箱发送到thingsboard登录绑定的google邮箱
但成功一次后总是发送失败，重新启用IMAP/SMTP服务可以成功，之后一直成功

###修改后的thingsboard用户和密码
lhdeng320@gmail.com   sysadmin

#9月25日
计算机网络 1p

#9月26日
计算机网络 1p

#9月29日
计算机网络 1p-2p

#10月3日
###cmd命令行发送向指定端口post请求
curl -v -X POST -d {\"firmware_version\":\"1.0.1\", \"serial_number\":\"SN-001\"}" http://$THINGSBOARD_HOST:$THINGSBOARD_PORT/api/v1/$ACCESS_TOKEN/attributes --header "Content-Type:application/json"

curl -v -X POST -d "{\"temperature\": 25}" http://$THINGSBOARD_HOST:$THINGSBOARD_PORT/api/v1/YhkgZboN7o1gNfMr2ZMv/telemetry --header "Content-Type:application/json"


curl -v -X POST -d "{\"firmware_version\":\"1.0.1\", \"serial_number\":\"mqttfx\"}" http://localhost:801/api/v1/auczidVZB783Uf2oeJlv/attributes --header "Content-Type:application/json"

curl -v -X POST -d "{\"temperature\": "dlh"}" http://localhost:801/api/v1/auczidVZB783Uf2oeJlv/telemetry --header "Content-Type:application/json"

###使用mqtt.fx给thingsboard发送嵌套的json数据
须修改根规则链，在保存数据之前需要加一个script标签进行过滤，获取处理过的扁平化数据并进行展示
	
#10月4日
计算机网络 3p

#10月6日
计算机网络 4p

###区分localhost、127.0.0.1、本机ip
localhost 不联网；不使用网卡、不受防火墙和网卡限制；本机访问

127.0.0.1 不联网；网卡传输、受防火墙和网卡限制；本机访问

本机ip 联网；网卡传输、受防火墙和网卡限制；本机或外部访问

#10月7日
计算机网络 5p-10p

#10月8日
计算机网络 11p-14p

#10月9日
计算机网络 15p-19p

#10月10日
计算机网络 20p-28p

#10月11日
计算机网络 29p-30p

#10月12日
计算机网络 32p

#10月13日
计算机网络 33p-34p、36p-38p

#10月15日
计算机网络 39p-42p、44p

#10月16日
计算机网络 45p-49p
大话数据结构

#10月17日
计算机网络 50p-53p

###wsl位置迁移_win10使用WSL 2运行Docker Desktop，运行文件从C盘迁移到其他目录
https://blog.csdn.net/weixin_33245735/article/details/112580143
docker desktop在安装的时候创建两个wsl子系统，使用命令wsl -l -v --all可查看。
其中，docker-desktop是存放程序的，docker-desktop-data是存放镜像的，这两个wsl子系统都是默认放在系统盘的

1.将 docker-desktop-data 导出到 E:\Project\wsl\docker-desktop-data
运行wsl --export docker-desktop-data E:\Project\wsl\docker-desktop-data\docker-desktop-data.tar
2.注销 docker-desktop-data
运行wsl --unregister docker-desktop-data
3.重新导入 docker-desktop-data 到要存放的文件夹E:\Project\wsl\docker-desktop-data
运行wsl --import docker-desktop-data E:\Project\wsl\docker-desktop-data\ E:\Project\wsl\docker-desktop-data\docker-desktop-data.tar --version 2

#10月21日

###记录thingsboard2.4编译成功所遇到的问题
整体步骤：https://blog.csdn.net/bruceRong/article/details/99686656
编译失败后一定要先mvn clean,然后再mvn clean install -Dmaven.test.skip=true
1.[INFO] Thingsboard HTTP Transport Common .......SUCCESS [  0.770 s] 编译失败
在maven的setting.xml文件中增加镜像源
    <mirror>
      <id>aliyunmaven</id>
      <mirrorOf>*</mirrorOf>
      <name> Alibaba cloud public warehouse </name>
      <url>https://maven.aliyun.com/repository/public</url>
    </mirror>
在thingsboard的pom.xml文件中的<repositories></repositories>标签中增加
    <repository>
      <id>alimaven</id>
      <name>aliyun maven</name>
      <url>http://maven.aliyun.com/nexus/content/groups/public</url>
    </repository>

2.[INFO] ThingsBoard JavaScript Executor Microservice .. SUCCESS [01:01 min]编译失败
解决问题的来源https://blog.csdn.net/IoTSchool/article/details/104706679

在https://github.com/zeit/pkg-fetch/releases或者https://github.com/vercel/pkg-fetch/releases/tag/v2.6中下载fetched-v10.15.3-linux-x64和fetched-v10.15.3-win-x64（原名均为uploaded-v2.6-node-v10.15.3必须要改名字才可以）两个文件，v10.15.3针对thingsboard2.4版本，如果是3.0则是fetched-v10.17.0，这两个文件的目录是C:\Users\了一\.pkg-cache\v2.6


###thingsboard2.4在IDEA中运行成功问题记录
1.刚导入程序时IDEA中出现Cannot resolve com.sun.tools:   
java版本不对，在IDEA中修改Project SDK即可

2.Error:(25, 45) java: 程序包org.thingsboard.server.common.msg.gen不存在
我是在IDEA中下载GenProtobuf插件
添加protobuf插件这些类是通过protobuf自动生成的，需要在执行java编译前进行maven clean install

#10月23日
计算机网络 58p-60p

#10月25日
计算机网络 61p-62p

#10月26日
计算机网络 68p-70p、73p-74p完结

#10月31日
恋上数据结构 1p-13p

###数据结构是计算机存储、组织数据的方式
线性结构：线性表（数组、链表、栈、队列、哈希表（散列表））
树形结构：二叉树、红黑树、AVL树、B树、堆、Trie、哈夫曼树、并查集
图形结构：邻接矩阵、邻接表

#11月1日
恋上数据结构 14p-15p

#11月2日
恋上数据结构 16p-18p

###new是向堆空间申请内存

#11月3日
恋上数据结构 19p-24p

###java类中除了Object类外有一个共同的父类，那就是java.lang.Object

#11月4日
恋上数据结构 25p-34p

###对象的内存管理问题
   对于引用类型，对象数组Object[] objects = new Object[7];堆空间中放的是对象的内存地址
   对于基本数据类型，int[] datas = new int[7];堆空间中分配4*7=28个连续的字节存储空间
###提醒JVM进行垃圾回收
   System.gc();

#11月5日
恋上数据结构 34p-40p

###抽象类实现接口不用实现接口中的所有方法，而继承了实现接口的抽象类的类，则需要实现抽象类中未实现的所有方法。
List(接口)--->AbstractList(抽象类，实现接口部分方法(即LinkedList、ArrayList的公共方法))--->LinkedList、ArrayList(继承抽象类，实现除抽象类实现的公共方法外的所有方法)

抽象类也是对所有公共行为进行提取，区别在于，它内部不仅有抽象方法，它还有普通方法，就是在抽象类中已经实现了，子类中不用再实现，当然你可以进行重写。

我的理解：接口其实也是一种抽象类，抽象类实现了接口的部分方法，剩下的未实现的接口方法就是抽象类中的抽象方法（这也就解释了为什么实现了接口的抽象类中没有抽象方法，因为抽象类中未实现的的接口方法都是该抽象类的抽象方法），继承了抽象类的子类则必须实现抽象类中未实现的所有接口方法

#11月6日
恋上数据结构 40p-60p

###均摊复杂度
对于动态数组add(E element)复杂度分析：最好O(1)最坏O(n)平均O(1)均摊O(1)
最坏是扩容的时候，可以这样想，每次扩容是与前面若干次add有关系的，可以将扩容的复杂度均摊到前面若干次，所以这种情况平均复杂度仍为O(1)

###双向链表与动态数组
*如果频繁在尾部进行添加、删除操作，动态数组、双向链表均可选择；
*如果频繁在头部进行添加、删除操作，建议选择使用双向链表；
*如果有频繁的（在任意位置）添加、删除操作，建议选择使用双向链表；
*如果有频繁的查询操作（随机访问操作），建议选择使用动态数组

***单链表在哈希表的设计中使用

#11月7日
恋上数据结构 61p-70p

#11月8日
恋上数据结构 71p

#11月10日
恋上数据结构 72p-78p

#11月11日
恋上数据结构 79p-84p

###程序中应避免使用*、/、%、浮点数运算，效率低，应使用+、-、位运算来替代

###树的一些概念
节点的度：子树的个数
树的度：所有节点度中的最大值
节点的深度：从根节点到当前节点的唯一路径上的节点总数
节点的高度：从当前节点到最远叶子节点的路径上的节点总数，若节点是叶子节点，则高度为1
树的深度：所有节点深度的最大值
树的高度：所有节点高度的最大值
树的深度 = 树的高度

#11月12日
恋上数据结构 85p-101p

###二叉树 Binary Tree
1.每个节点的度最大为2
2.左子树和右子树是有顺序的
3.即使某节点只有一棵子树，也要区分左右子树
性质：
1.非空二叉树的第i层，最多有2^(i-1)个节点（i>=1）
2.在高度为h的二叉树上最多有2^h-1个节点（h>=1）
3.对于任何一棵非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则n0=n2+1（从二叉树的边数入手证明）

真二叉树：所有节点的度要么为0，要么为2

满二叉树：所有节点的度要么为0，要么为2，且所有的叶子节点都在最后一层

***在同样高度的二叉树中，满二叉树的叶子节点最多，总节点数最多；满二叉树一定是真二叉树，真二叉树不一定是满二叉树

完全二叉树：叶子节点只会出现最后2层，且最后一层的叶子节点都靠左对齐
性质：
1.度为1的节点只有左子树
2.度为1的节点要么是1个，要么是0个
3.同样节点数量的二叉树，完全二叉树的高度最小
4.假设完全二叉树的高度为h（h>=1），那么至少有(2^(h-1) - 1) + 1即2^(h-1)个节点，最多有2^h-1
h = floor(log2n) + 1   (floor向下取整，ceiling向上取整)
5.一棵有n个节点的完全二叉树（n>0），从上到下，从左到右对节点从1开始进行编号，对任意第i个节点：
*如果i=1，它是根节点
*如果i>1，它的根节点编号为floor(i/2)
*如果2i<=n,它的左子节点编号为2i
*如果2i>=n,它无左子节点
*如果2i+1<=n,它的右子节点编号为2i+1
6.如果完全二叉树的节点为n，则叶子节点数为 n0 = (n+1)>>1(编程语言)使用到了性质2

***满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

###二叉搜索树
任意一个节点的值都大于其左子树所有节点的值；
任意一个节点的值都小于其右子树所有节点的值
它的左右子树也是一棵二叉搜索树

#11月13日
恋上数据结构 101p-115p

###数据结构的一些网站
◼ http://520it.com/binarytrees/
◼ http://btv.melezinek.cz/binary-search-tree.html
◼ https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
◼ https://yangez.github.io/btree-js
◼ https://www.codelike.in

###二叉搜索树的中序遍历结果是升序或者降序的
遍历是针对二叉树来说的

###遍历的应用
前序遍历：树状结构展示（注意左右子树的顺序）
中序遍历：二叉搜索树的中序遍历按升序或者降序处理节点
后序遍历：适用于一些先子后父的操作
层序遍历：计算二叉树的高度；判断一棵树是否为完全二叉树

#11月14日
恋上数据结构 115p-129p

###根据遍历结果重构二叉树
以下结果可以保证重构出唯一的一棵二叉树
1.前序遍历+中序遍历
2.后序遍历+中序遍历

3.前序遍历+后序遍历
如果它是一棵真二叉树，结果是唯一的；不然结果不唯一

###如果一个节点的度为2，那么它的前驱和后继节点的度只可能是1和0
【加深理解】若该节点度为2，那么说明该节点既有左子树也有右子树，以前驱为例，在有左子树的情况下找前驱，则是沿着左子树一直往右找直到右子节点为空，所以该节点的前驱的度只能是1或者0

###二叉搜索树的复杂度为O(h)即与树的深度有关，等于O(logn)   2^h - 1 = n

#11月15日
恋上数据结构 130p-132p

###平衡二叉搜索树：AVL树、红黑树
AVL树：每个节点的平衡因子只可能是1、0、-1

#11月16日
专利大作业

#11月17日
恋上数据结构 133p-153p

###Comparable与Comparator的使用
二者都是接口前者提供了public int compareTo(T o); 后者提供了int compare(T o1, T o2);都是用于比较。
下面介绍一种使用方法，由于二叉搜索树的节点元素是有一定顺序的，因此二叉搜索树类中是需要比较方法的，小码哥的方案是这样的：在类中创建一个私有变量comparator作为有参构造函数的一个参数，同时也写一个无参构造函数，类中的比较方法为若comparator不为空则调用comparator的方法compare(T o1, T o2)返回比较结果，若comparator为空，则将e1强转为Comparable对象并调用compareTo(T o)方法返回比较结果。在创建二叉搜索树对象时，可以使用有参构造函数即创建一个匿名函数并实现compare(T o1, T o2)方法，这样树中的节点元素类可以不用实现Comparable接口，若使用无参构造函数，树中的节点元素类则必须要实现Comparable接口，否则无法比较。二叉搜索树中的比较方法如下：

	/**
	 * @param e1
	 * @param e2
	 * @return 返回值等于0代表e1=e2，返回值大于0，代表e1大于e2，返回值小于0，代表e1小于e2
	 */
	private int compare(E e1,E e2) {
		if(comparator != null) {
			return comparator.compare(e1, e2);
		}
		return ((Comparable<E>) e1).compareTo(e2);
	}

###AVL树总结
对于二叉搜索树的添加，可能会导致所有祖先节点都失衡；只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需O(1)次调整】

对于二叉搜索树的删除，可能导致父节点或祖先节点失衡（只有1个节点会失衡，其他节点都不可能失衡）；让父节点恢复平衡后，可能会导致更高层的祖先节点失衡【最多需要O(logn)次调整】

平均时间复杂度：搜索O(logn)、添加O(logn)，仅需O(1)次的旋转操作、删除O(logn)，最多需要O(logn)次的旋转操作

###红黑树性质
1.节点是RED或者BLACK
2.根节点是BLACK
3.叶子节点（外部节点，空节点）都是BLACK
4.RED节点的子节点都是BLACK
5.从任一节点到叶子节点的所有路径都包含相同数目的BLACK节点

#11月18日
恋上数据结构 153p-155p

###B树
是一种平衡的多路搜索树，多用于文件系统、数据库的实现
m阶B树的性质（m>=2）
假设一个节点存储的元素个数为x
根节点：1<=x<=m-1
非根节点：ceiling(m/2)-1<=x<=m-1

如果有子节点，子节点个数y=x+1
根节点：2<=y<=m
非根节点：ceiling(m/2)<=y<=m
比如：m=3，2<=y<=3,因此可称为（2，3）树、2-3树、3阶B树
m=4，2<=y<=4,因此可称为（2，4）树、2-3-4树、4阶B树
m=5，3<=y<=5,因此可称为（3，5）树、3-4-5树、5阶B树

特殊的，4阶B树
所有节点能存储的元素个数x：1<=x<=3
所有非叶子节点的子节点个数y：2<=x<=4

###数据库中一般用200-300阶B树

###B树和二叉搜索树在逻辑上是等价的
n代合并的超级节点，最多拥有2^n个子节点（至少是2^n阶B树）
m阶B树，最多需要log2(m)代合并

#11月20日
恋上数据结构 156p-161p 192p-197p

###集合（Set）
特点：不存放重复的元素，常用于去重
TreeSet底层是用红黑树实现的，添加、搜索、删除复杂度是logn

#11月21日
恋上数据结构 198p-208p

###映射（Map）
在有些编程语言中也叫做字典，Map中每个key是唯一的
TreeMap底层是用红黑树实现的，添加、搜索、删除复杂度是logn
Map的键就是一个Set

#11月22日
恋上数据结构 208p-213p

###哈希表（Hash Table）
也叫散列表，典型的【**空间换时间**】
哈希表具体实现是通过给哈希函数一个key找到table（是一个数组）中的索引进行添加、搜索、删除

【**自定义对象作为key的要求**】在java中，当自定义的对象想作为HashMap的key时，则最好同时实现hashCode方法（计算索引时调用，必须保证equals为true的两个key的哈希值一样）、equals方法（哈希冲突比较key是否相等时调用，用以判断两个key是否为同一个key），也允许key为null。因为继承的Object类中虽然有hashCode方法和equals方法，但是hashCode方法是按照内存地址来算的哈希值，equals方法是按照内存地址来进行比较的，一般不能满足要求。

###哈希冲突
2个不同的key，经过哈希函数计算出相同的结果（索引）
解决哈希冲突的常见方法：
1.开放定址法（按照一定规则向其他地址探测，直到遇到空桶为止）
2.再哈希法（涉及多个哈希函数）
3.链地址法（比如通过链表将同一index的元素串起来）

JDK1.8的哈希冲突解决方案【**使用链表+红黑树解决**】
默认使用单向链表将元素串起来，当添加元素时，可能会由单向链表转为红黑树来存储元素；当红黑树节点数量少到一定程度时，又会转为单向链表【**索引相同时，依次比较桶数组中该索引存储的数据的key值，若key相同则覆盖，若不同则添加到链表尾部，那么key就需要实现equals方法**】

###哈希函数
1.先生成key的哈希值（必须是整数）
2.再让key的哈希值跟数组的大小进行相关运算，生成一个索引值

return hash_code(key) % table.length;
为了提高效率，可以使用&位运算符取代%运算【**前提：将数组的长度设计为2的幂（2^n）**】
return hash_code(key) & (table.length - 1);【**太妙了**】

【**良好的哈希函数**】
让哈希值更加均匀分布-->减少哈希冲突次数-->提升哈希表的性能

#11月23日
恋上数据结构 214p

#11月24日
恋上数据结构 215p-218p

###31是一个奇素数，JVM会将31*i优化为（i<<5）-i；并且素数和其他数相乘的结果比其他方式更容易产生唯一性，减少哈希冲突。

###java中的.class文件是java编译后的文件，是二进制文件，在eclipse或其他编译器中看到的.class文件之所以跟.java文件没区别是因为被开发工具反编译了

#11月25日
恋上数据结构 219p-227p

###getClass()与instanceof关键字
obj1.getClass() == obj2.getClass();
obj1 instanceof obj2;
假设Student类是Person类的子类，前者判断Student.class == Person.class，很明显为false；后者则为true

#11月27日
恋上数据结构 227p-231p

#12月21日
恋上数据结构 232p-234p

#12月22日
恋上数据结构 235p-255p

#12月23日
恋上数据结构 256p-263p 272p-273p

###equals规范
1.自反性 对任何非null的x，x.equals(x)=true
2.对称性 对任何非null的x，y，y.equals(x) = x.equals(y)
3.传递性 对任何非null的x，y，z，若x.equals(y),y.equals(z)都为true,那么x.equals(z)也为true
4.一致性 对任何非null的x，y，只要equals的比较对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true或者一致地返回false
5.对于任何非null的x，x.equals(null) = false

###TreeMap与HashMap
复杂度
TreeMap O(logn)
HashMap O(1)
【**何时选择TreeMap？**】
元素具备可比较性且要求升序遍历（按照元素从小到大）
【**何时选择HashMap？**】
无序遍历

###堆（Heap）二叉堆
一种树状的数据结构，任意节点的值总是>=(<=)子节点的值，堆中元素必须具备可比较性（跟二叉搜索树一样）

#12月25日
SpringBoot2 1p-5p

#12月26日
SpringBoot2 6p-14p 16p-19p

###@Configuration(proxyBeanMethods = *) 解决组建依赖
可以这样理解组件依赖，需要依赖组件就是需要创建新组件时，而这两个模式在getBean时都是从IOC容器中拿的同一个组件，使用Full模式来保证取得的组件为IOC中的同一组件

proxyBeanMethods：代理bean的方法
	Full（proxyBeanMethods = true）保证每个@Bean方法被调用多少次返回的组件都是单实例的
	Lite（proxyBeanMethods = false）保证每个@Bean方法被调用多少次返回的组件都是新创建的，轻量化，配置类组件之间无依赖关系时用Lite模式加速容器启动过程，减少判断

当proxyBeanMethods = true，外部无论对配置类中这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象，例如：
	ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);
    MyConfig bean = run.getBean(MyConfig.class);
    User user = bean.user01();
    User user1 = bean.user01();

    System.out.println(user);  //"denglihui",22
    user1.setName("zhangsan");
    System.out.println(user);  //"zhangsan",22
说明user和user1是同一个对象
然而，当proxyBeanMethods = false，user与user1就是创建的不同的对象了，上面最后一行输出的仍然是"denglihui",22

###@Component 和 @Bean
https://blog.csdn.net/w605283073/article/details/89221522
@Component 和 @Bean 是两种使用注解来定义bean的方式。

@Component 直接在类上方注解，这个类要么必须有无参构造方法，要么就一个构造方法也不写
@Bean则常和@Configuration注解搭配使用，即需要在配置类中使用，如果想将第三方的类变成组件，你又没有没有源代码，也就没办法使用@Component进行自动配置，这种时候使用@Bean就比较合适了。

###继承派生和多态
https://blog.csdn.net/qq_37856300/article/details/83383856
继承派生就是子类添加了新功能
多态在java中指的是继承父类或者实现接口时有多种继承状态和实现方式，即重写
比如，有一个父类猫类，子类有家猫，波斯猫，玩偶猫
猫 cat = new 波斯猫();调用的公共方法是波斯猫中重写的方法，但波斯猫特有的方法cat调用不了

#12月27日
SpringBoot2 20p

###yml文件中的单引号与双引号
"zhangsan \n lisi"
单引号会输出\\n，即将\n作为符号输出
双引号会输出换行
双引号可以理解为跟Java中一样

#12月28日
SpringBoot2 21p-25p

###springboot静态资源设置
1.静态资源目录访问顺序
META-INF/resources -> resources -> static -> public
2.静态资源设置
spring:
  mvc:
    static-path-pattern: /res/**     //静态资源访问前缀
  resources:
    static-locations: classpath:/public    //指定静态资源访问目录
经过测试，外部库的静态资源文件是不受上面配置影响的，如访问依赖jquery3.5.1下的jquery.js文件http://localhost:8081/webjars/jquery/3.5.1/jquery.js，其中webjars是在META-INF/resources文件夹中的
web图标favicon.ico与欢迎页index.html是会受上面配置影响的

#12月29日
SpringBoot2 26p-27p 29p-30p

###表单只能提交get或者post请求
要想提交put、delete请求表单需要使用post请求并增加一个隐藏参数
<input name="_method" type="hidden" value="delete" />
另外spring.mvc.hiddenmethod.filter.enabled = true //开启页面表单的Rest功能

#12月30日
SpringBoot2 31p 37p 42p

#12月31日
SpringBoot2 42p-43p

###@RestController与@Controller区别
@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用
1.如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。
2.如果需要返回到指定页面，则需要用 @Controller配合视图解析InternalResourceViewResolver才行。
3.如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加@ResponseBody注解。


#2022


#1月1日
SpringBoot2 44p-46p

###session与model的区别
1.session里放的数据可以在其他页面使用，比如用户信息，后端放入session：
request.getSession().setAttribute("manage", manage);
session生命周期内，前端的很多页面都可以使用
2.model的数据，只能在接下来的页面使用，其他页面就不能使用,比如从数据库获得的list<对象>信息，在下一个页面，循环遍历展示后端放入model
3.存入session后，取出数据使用get（）方法，像是对象，而model使用点，有点类似json字符串

#1月2日
SpringBoot2 47p-48p 50p 52p 56p

###springboot|Controller接收处理GET,POST请求入参
https://blog.csdn.net/weixiaodedao/article/details/106710432?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.queryctr&spm=1001.2101.3001.4242.1&utm_relevant_index=3

###过滤，监听，拦截
Filter用于字符过滤，Listener用于初始化作用域数据，interceptor用于拦截请求

【**拦截器的使用**】创建一个实现了HandlerInterceptor的类重写其preHandle方法（返回true为放行，false为拦截），并在@Configuration注解下实现了WebMvcConfigurer的类中重写addInterceptors方法
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/","/login","/css/**","/fonts/**","/images/**","/js/**");
    }

Web原生组件注入（Servlet、Filter、Listener）
使用@WebServlet("/my"):直接响应，不经过spring的拦截器

#1月3日
SpringBoot2 57p 60p 63p
 
###springboot定制化的常见方式
web应用 编写一个配置类实现WebMvcConfigurer即可定制化web功能 + @Bean给容器中再扩展一些组件，视图解析器，比如拦截器的使用

#1月4日
SpringBoot2 64p

#1月5日
SpringBoot2 65p-68p

###MybatisPlus使用
若使用mysql数据库，则添加mysql驱动
1.mysql驱动：默认8.0.22
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
2.引入mybatisPlus依赖：
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.1</version>
</dependency>
3.mybatisPlus会自动配置mapper-locations，默认目录为classpath:/mapper/*.xml；mybatis则需要自己配置mybatis.mapper-locations
4.xxx多为实体类
xxxDao（xxxMapper）文件继承BaseMapper<xxx>，需要@Mapper注解
xxxService接口继承IService<xxx> 不需要@Service注解
xxxService接口实现类xxxServiceImpl继承ServiceImpl<xxxDao,xxx>并实现xxxService接口，需要@Service注解
xxxController中注入xxxService接口，并在方法中使用xxxService的增删改查方法

###记录一个问题，使用mybatisplus时，查询的部分字段为null
原因是实体类中该字段为last_name，改为lastName并开启驼峰命名即可，这个问题在mybatis中没有，可能是plus版本对于有下划线的字段无法映射到数据库中对应字段的缘故
mybatis:
  configuration:
    map-underscore-to-camel-case: true

###springboot在本机使用Redis
1.打开redis
2.引入依赖
引入redis,默认2.4.1
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
引入jedis，默认3.3.0
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
</dependency>
3.配置redis连接
spring:
  redis:
    host: localhost
    port: 6379
    client-type: jedis
    lettuce:
      pool:
        max-active: 10
        min-idle: 5
4.使用自动注入的redisTemplate对象    
@Autowired
StringRedisTemplate redisTemplate;
ValueOperations<String,String> opsForValue = redisTemplate.opsForValue();
opsForValue.set("","");

#1月6日
SpringBoot2 69p-72p 单元测试和指标监控模块先跳过
java多线程 1p-7p

###Redis on Window
https://www.cnblogs.com/zwwhnly/p/12185696.html

###@Autowired注解相关
若是在A类中使用了@Autowired自动注入注解，那么在B类中new这个A类时则A类中的自动注入注解是无效的，因为只有容器中的组件才能使用这个注解，因此需要在A类上加一个@Component将这个类放到容器中，在B类中使用A类通过@Autowired自动注入即可

###Filter、Interceptor几乎拥有相同的功能
1.Filter是servlet定义的原生组件，脱离了spring应用也能使用
2.Interceptor是spring定义的接口，可以使用spring的自动装配等功能

###进程和线程
进程：是程序的一次执行过程，或是正在运行的一个程序
线程：进程可进一步细化为线程，是一个程序内部的一条执行路径，线程是调度和执行的最小单位

每个线程，拥有自己独立的：栈、程序计数器
多个线程共享同一个进程中的结构：方法区、堆

一个java应用程序java.exe，其实至少三个线程，main()主线程、gc()垃圾回收线程、异常处理线程，如果发生异常，会影响主线程

###并行与并发
并行：多个CPU同时执行多个任务，比如：多个人同时做不同的事
并发：一个CPU（采用时间片）同时执行多个任务，比如：秒杀、多个人做同一件事

###创建多线程的四种方法
方式一：继承Thread类的方法
1.创建一个继承于Thread类的子类
2.重写Thread类的run()--->将此线程执行的操作声明在run()中
3.创建Thread类的子类
4.通过此对象调用start()
两个问题：
1.不能通过直接调用run()的方式启动线程
2.再启动一个线程，不可以让已经start()的线程去执行，需要重新创建一个对象，然后调用此对象的start()

方式二：实现Runnable接口的方式
1.创建一个实现了Runnable接口的类
2.实现类去实现Runnable中的抽象方法：run()
3.创建实现类的对象
4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5.通过Thread类的对象调用start()

两种方法对比：
开发中：优先选择实现Runnable接口的方式
原因：
1.实现的方式没类的单继承性的局限性
2.实现的方式更适合来处理多个线程共享数据的情况
联系：class Thread implements Runnable，继承的Thread类本质也是实现了Runnable接口
相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中

方式三：实现Callable接口
1.创建一个实现Callable的实现类
public class MyCallable implements Callable<T> {
    @Override
    public Integer call() throws Exception {
    }
}
2.实现call方法，call方法可以有返回值
3.创建创建Callable接口实现类的对象
MyCallable myCallable = new MyCallable();
4.将此Callable接口实现类的对象传递到FutureTask的构造器中，创建FutureTask的对象
FutureTask<T> futureTask = new FutureTask<>(myCallable);
5.将FutureTask的对象作为参数传递到Thread的构造器中
new Thread(futureTask).start();
6.可以获取call方法的返回值如System.out.println(futureTask.get());

方式四：使用线程池
//1.提供指定线程数量的线程
ExecutorService executorService = Executors.newFixedThreadPool(10);
//2.执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
executorService.execute(new NumberThread()); //适用于Runnable
executorService.execute(new NumberThread1()); //适用于Runnable
//executorService.submit();  //适用于Callable
//3.关闭连接池
executorService.shutdown();

###线程安全的问题
https://blog.csdn.net/sinat_42483341/article/details/105332156
在java中通过同步机制来解决线程安全的问题，操作同步代码时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低

方式一：同步代码块
synchronized(同步监视器){
	//需要被同步的代码
}
说明：
1.操作共享数据的代码，即为需要被同步的代码
2.共享数据：多个线程共同操作的变量
3.同步监视器：俗称：锁。任何一个类的对象都可以充当锁，一般方式一方法（继承Thread）用类.class,方式二方法（实现Runnable）用this
【**要求**】多个线程必须要用同一把锁

方式二：同步方法
如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的

方式三：Lock锁
1.private ReentrantLock lock = new ReentrantLock();
2.lock.lock();  //一般跟被同步的代码一块放入try中
3.lock.unlock();  //一般放入finally中

###synchronized与Lock的异同？
相同：二者都可以解决线程安全的问题
不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器；Lock需要手动的启动同步（lock()），同时技术同步也需要手动的实现（unlock()）

#1月7日
java多线程 8p-20p 结束

###线程的死锁问题
死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁

解决办法：
专门的算法、原则
尽量减少同步资源的定义
尽量避免嵌套同步

###wait()与sleep()
二者都会使线程阻塞，但执行wait()时会释放锁，而sleep()不会，因此常使用wait()与notify()搭配实现多线程交替打印

不同：
1.两个方法声明的位置不同：wait()声明在Object类中，sleep()声明在Thread类中
2.调用的要求不同，sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码中
3.若两个方法都使用在同步代码块或者同步方法中，sleep不会释放同步监视器，而wait会释放

###wait(),notify(),notifyAll()
【**注意**】
1.wait(),notify(),notifyAll()三个方法必须使用在同步代码块或者同步方法中；
2.wait(),notify(),notifyAll()三个方法的调用者必须是同步代码块或者同步方法中的同步监视器，否则会出现异常
3.wait(),notify(),notifyAll()三个方法是在Object类中定义的

#1月8日
Linux 1-11p

#1月9日
Linux 12p-14p

###Window与CentOS 7共享文件夹设置后CentOS中不显示的问题
https://www.cnblogs.com/xxdebug/p/14009776.html
查询命令
cd /mnt/hgfs         
ls
ls之后若不显示执行
yum -y install open-vm-tools
vmhgfs-fuse .host:/ /mnt/hgfs
若第二句有问题再执行vmhgfs-fuse .host:/ /mnt/hgfs -o nonempty -o allow_other

#1月10日
Linux 15p 
java枚举和注解 4p-9p

###Linux下的vim操作
vim xxx会在默认目录下创建xxx，进去之后是一般/正常模式，点i或a进入编辑/插入模式，点esc进入命令模式，在命令模式下可以输入一些命令，比如u为撤销，yy为复制(光标需要放到要复制的那一行)，p为粘贴，输入 /搜索内容 可以搜索，输入:wq则为保存退出至命令行

###枚举类相关
使用enum关键词代替class，其实就是一个类有有限个对象
省略public static final
定义的枚举类默认继承于java.lang.Enum而不是Object

#1月11日
java枚举和注解 10p-18p
微信支付springboot+vue 1p-16p

#1月12日
微信支付springboot+vue 16p-25p


###设置nodejs的全局安装文件的路径和缓存
1.下载nodejs
在cmd中用node -v来查看
2.创建一个npm文件夹，最好不在nodejs安装文件中，在npm文件夹中再创建两个文件夹node_global和node_cache（缓存）
3.用户变量PATH添加一个E:\Install\npm\node_global
4.在系统变量中创建一个NODE_PATH变量变量值为E:\Install\nodejs\node_modules
5.用管理员启动cmd执行
npm config set prefix "E:\Install\npm\node_global"
npm config set cache "E:\Install\npm\node_cache"

###vue 全局安装脚手架
设置淘宝镜像地址
npm config set registry https://registry.npm.taobao.org
全局安装脚手架
npm install -g @vue/cli

###关于VSCode中vue命令无法识别的解决
可能的原因1
由于修改了node下载文件的全局路径，可能VSC找不到全局文件中的vue.cmd，故在系统变量Path中设置vue.cmd的路径，这个由于在用户变量的Path中也设置过了，所以系统变量中删了这个路径也无妨
可能的原因2
我的问题是这个，VSC中的策略问题
使用管理员身份运行VSC，在终端查看当前策略get-ExecutionPolicy，若是Restricted则使用
Set-ExecutionPolicy RemoteSigned修改为RemoteSigned即可
参考博客https://blog.csdn.net/Alex_ddC/article/details/111596110

###vue相关
指定运行端口号
进入前端文件的文件夹中执行
npm run serve -- --port 8081

#1月13日
微信支付springboot+vue 26p-27p
java设计模式 1p-10p

###springboot中配置类中的数据与配置文件绑定
一般，配置类中的属性名字是驼峰命名，配置文件是下划线
1.配置类上的注解为
@Configuration
@PropertySource("classpath:wxpay.properties") //读取配置文件
@ConfigurationProperties(prefix="wxpay") //读取wxpay节点，识别配置文件中wxpay前缀的数据
@Data //使用set方法将wxpay节点中的值填充到当前类的属性中
配置类中的属性举例
private String mchId;
2.配置文件中数据举例
wxpay.mch-id=1558950191

要想从配置文件定位到配置类的属性上去，需要加一个依赖
	<!-- 生成自定义配置的原数据信息 -->
	<dependency>
	    <groupId>org.springframework.boot</groupId>
	    <artifactId>spring-boot-configuration-processor</artifactId>
	    <optional>true</optional>
	</dependency>
加完依赖后要重启项目

###@Resource和@AutoWired
https://blog.csdn.net/weixin_40423597/article/details/80643990
https://www.yuque.com/docs/share/fe2e6770-216c-4ea8-a56c-3c94b90faf46
@Resource  默认通过名称注入 ，如名称无找到则通过类型注入
@AutoWired 默认通过类型注入，如存在多个类型则通过名称注入，如果有多个类型相同的bean时需要@Qualifier("beanName")注解来通过名字进行注入 

经测试：
@Resource
private IUserService userService;  //根据名称注入的，名称就是对象名称userService
1.存在一个实现类： UserServiceImpl.java 自动注入UserServiceImpl 实现
2.如果存在多个实现类：UserServiceImpl.java 、  UserServiceImpl2.java 则抛出异常
3.如果存在多个实现类：UserServiceImpl.java 、  UserService.java 则根据名称注入UserService.java

对于例子2，可使用下面两种方法解决
1.@Autowired
@Qualifier("userServiceImpl")
private IUserService userService;
2.@Resource
private IUserService userServiceImpl2; 

###设计模式七大原则
高内聚、低耦合、面向接口编程
1.单一职责原则  一个类实现单一的职责
2.接口隔离原则  实现接口的类要能用到接口中的所有方法
3.依赖倒转原则  为降低类之间的耦合，类中方法的形参使用接口，调用方法传递实现类
4.里氏替换  继承的子类尽量不重写父类的方法
5.开闭原则  对扩展功能开放，对修改代码关闭，即少改已有代码，多去新增拓展
6.迪米特法则  一个对象应该对其它对象保持最少的了解，也就是说，陌生的类最好不要以局部变量的形式出现在类的内部，可以以成员变量，方法参数，方法返回值的形式出现在类的内部
7.合成复用原则  尽量使用合成/聚合的方式，而不是使用继承

#1月14日
java设计模式 11p-25p

#1月15日
java设计模式 26p-52p

###类图六大关系
依赖、继承、实现、关联、聚合（类中其他类只声明）、组合（类中其他类new，即同生共死）

###类装载  类装载过程中是不存在线程问题的，这是jvm的保护机制
https://www.cnblogs.com/cbw052/p/10610135.html
在任何时刻，第一次访问某类，都会执行类装载
访问包括三种情况：
使用某类的static方法
访问某类的static属性
构造某类的对象
声明没有初始化的引用Administrator admin;,并不会导致类装载(This is lazy load)
一个类的装载只会执行一次

#1月16日
java设计模式 53p-60p

###对象序列化

#1月17日
java设计模式 61p-88p

#1月18日
java设计模式 89p-123p

###String、Integer等在堆空间new出来的对象若内容在常量池中有相等的，则堆空间中存的是常量池中该值的地址
String s = "hello";
String s1 = new String("hello");
s == s1 //true

###代理模式
静态代理 目标对象与代理对象都需要实现接口，在代理对象中聚合目标对象，在代理对象方法中调用目标对象的方法并进行增强，类似AOP面向切面

https://www.cnblogs.com/miracle-d/p/10775015.html
动态代理(JDK代理) 目标对象需要实现接口，代理对象不需要实现接口；如果在目标对象的方法中调用目标对象的方法，那么增强就会失效；在使用目标对象时需要将代理对象强转为目标对象实现的接口才行，并将目标对象作为参数传入代理对象
JDK动态代理对实现类对象做增强得到的增强类与实现类是兄弟关系，所以不能用实现类接收增强类对象，只能用接口接收。

cglib代理 代理的类不能为final；Cglib代理类和实现类之间是父子关系，自然可以用实现类去接收代理类对象

#1月19日
java设计模式 124p-140p

#1月20日
java设计模式 141p-145p

#1月21日
java设计模式 146p-149p 完结

#2月2日
java反射

###反射
加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为反射。

正常方式：引入需要的包类名称--->通过new实例化--->取得实例化对象
反射方式：实例化对象--->getClass()方法--->得到完整的包类名称

###如何看待反射机制与封装性

###关于java.lang.Class类的理解    类本身也是对象
1.类的加载过程：
(类的编译)程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。
接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。
2.换句话说，Class的实例就对应着一个运行时类。

###类的加载过程
加载：将类的class文件读入内存，并为之创建一个java.lang.Class对象
链接：为类变量分配内存并设置类变量默认初始值
初始化：静态代码块和显式赋值

#2月16日
恋上数据结构
redis6 1p-5p

###Linux安装Redis6
使用CentOs7,Redis6.2.1，安装到/opt
1.先检查opt文件夹中是否有redis安装包
cd /opt
ls
2.安装GCC
gcc --version有的话就不用装了
yum install gcc
3.解压压缩包
tar -zxvf redis-6.2.1.tar.gz
解压完成后opt文件夹中会有多一个redis-6.2.1的文件夹
4.进入cd redis-6.2.1
执行make命令
执行结束后执行make install命令
如：
[root@hadoop1 opt]# cd redis-6.2.1
[root@hadoop1 redis-6.2.1]# make
[root@hadoop1 redis-6.2.1]# make install
5.执行完成后进入cd /usr/local/bin查看

推荐后台启动
[root@hadoop1 etc]# cd /usr/local/bin
[root@hadoop1 bin]# redis-server /etc/redis.conf
查询是否启动
[root@hadoop1 bin]# ps -ef | grep redis
关闭
[root@hadoop1 bin]# redis-cli shutdown

#2月17日
redis6 6p-26p

###java中的i++不是原子性操作
两个线程a，b从i=0执行i++ 100次，得到的结果是一个范围2-200
200好理解
对于2，i++分为三步，取值，++，赋值
a线程加99次后被b线程抢走，b中i加到1完成赋值后被a抢走，a中i取值为1，并++，赋值前又被b抢走直到b执行完，再执行a的赋值操作，此时i被a赋值为2，即最终结果为2

###redis中发布与订阅
1.打开两个客户端，在其中一个中订阅channel1
SUBSCRIBE channel1
2.在另一个客户端中发布消息
publish channel1 hello,lhdeng!
3.在第一个客户端中就可以看到发送的消息

#2月18日
redis6 27p-47p 完结

###缓存穿透、缓存击穿、缓存雪崩
缓存穿透：遭受恶意攻击，访问大量非正常的url（redis中没有，大量访问数据库）导致数据库崩溃
缓存击穿：redis中key（热门key）过期了，而这个key又被大量用户访问导致数据库崩溃
缓存雪崩：在极少的时间段，查询大量key的集中过期情况

###解决Redis无法使用ip访问（127.0.0.1可以访问）的情况
1.在redis.windows.conf文件中注释掉bind 127.0.0.1，并将protected-mode  yes改为 protected-mode  no；同理修改 redis.windows-service.conf 文件中相应内容
使用redis-server重启时出现
[52268] 18 Feb 22:41:32.599 # Warning: no config file specified, using the default config. In order to specify a config file use E:\Install\redis\redis-server.exe /path/to/redis.conf
说明配置文件没有起作用，执行第2步
2.在命令行中进入到redis安装路径下执行redis-server.exe redis.windows.conf命令
E:\Install\redis>redis-server.exe redis.windows.conf
执行完成后即可通过ip访问redis

#2月19日
恋上数据结构2 1p
kafka 1p-6p

###Redis Desktop连接不上Centos7上部署的redis数据库解决方法
https://blog.csdn.net/qq_35673617/article/details/80561489
redis需要设置密码

#2月20日
恋上数据结构2 2p-3p

#2月21日
恋上数据结构2 4p

#3月10日-3月16日
投标陪标文档以及技术协议

#3月17日
qt 1p-7p

#3月18日
qt 8p-20p

###宏Q_PROPERTY
Q_PROPERTY()是一个宏，用来在一个类中声明一个属性property，由于该宏是qt特有的，需要用moc进行编译，故必须继承于QObject类。

Q_PROPERTY(unsigned age READ getAge WRITE setAge NOTIFY ageChanged)
一个可选的NOTIFY信号，如果被定义了，信号将在属性的值改变时发出。信号必须带有一个参数，这个参数的类型必须与属性相同；参数保存的是属性的新值。
signals:
    void ageChanged(unsigned value);

#3月19日
qt 21p-24p

#3月20日
qt 25p-26p

#3月21日
qt 27p

###qt中model的理解
model用于将数据与界面进行分离，Qt中的模型视图结构分为模型、视图和代理，其中，模型与数据源通信，并为其他部件提供接口。

#3月26日
qt 30p 61p

###解决32位的Qt5.2及以上版本无法连接64位mysql问题（本人实际用32位Qt5.9.9连接64位mysql8.0.25）
https://blog.csdn.net/csdndenglu/article/details/120429380

去https://downloads.mysql.com/archives/c-c/下载mysql-connector-c-6.1.11-win32.zip，不必解压，复制其中的libmysql.dll到qt中mingw32的bin目录下即可

#3月29日

###qt调用opencv
配置pencv环境变量E:\Project\opencv331\build\install\x86\mingw\bin
在pro中引入
win32 {
INCLUDEPATH += E:\Project\opencv331\build\install\include
LIBS += E:\Project\opencv331\build\install\x86\mingw\lib\libopencv_*.a
}
头文件为
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>

#4月9日  
###计算机内存和磁盘的关系
https://blog.csdn.net/qq_34720818/article/details/108410627

###Java语言跨平台，C语言也是？
https://blog.csdn.net/qq_38496329/article/details/107859953

#5月2日
显控
###发送数据报文流程
在consoleWidget中定时器时间到-->触发sendControlCommand()槽函数，根据不同的模式发送不同的指令如手动模式sendManualModeControlCommand()-->拿到前端界面的数据并给手动控制指令结构体赋值-->发送更新信号updateManualModeControlInstruction(this->manualModeControlInstruction)-->在mainwindow中接收到更新信号后触发串口的receiveManualModeControlInstruction(ManualModeControlInstruction)-->在串口中调用DatagramPackUtils::packControlInfoDatagram(manualModeControlInstruction)将指令结构体打包成QByteArray-->向串口发送QByteArray类型的数据指令报文
###接收数据报文流程
串口发出readyRead()信号-->触发receiveDate()，用readAll()接收QByteArray类型的原始数据报，根据第三个字节知道获取的是何种数据，如1为光电载荷状态，将原始数据赋值结构体并携带结构体发送readyReadLoadstate(LoadStateView)信号-->在mainwindow中触发updateLoadState(LoadStateView)槽函数，调用infoDisplayLeftWidget的方法更新前端界面信息

地图
###点击地图上的图标显示右侧信息流程
在html的onSelect(e)中设置鼠标点击图标触发jsCallQT(targetId)槽函数-->在webcommunication中该槽函数触发displayTarget(id)信号-->在mainwindow中接收到信号后触发infodisplayrightWidget的targetInfoDisplay(qint64)槽函数，拿到目标的id后根据id获取目标的所有信息，调用更新前端界面的updateInfo()槽函数并建立数据改变触发该槽函数的信号与槽机制buildTargetConnection(target)
注：若未在图标上点击则触发jsCallQT(-1)
###数据改变触发图层更新流程
在mainwindow中定时时间到timeout()-->触发onTimeout()槽函数，调用TargetManager::instance()->getTargetsJson()获取数据库中的所有目标的数据并调用sendMsgToJs(jsonArray)发送targetsChange(jsonArray)信号-->map.html中接收到信号触发recvTargets(jsonArray)函数更新图层
###数据改变触发右侧信息更新流程
注：targetMap记录上次的查询的所有目标，mTargetMap记录本次查询的所有目标
前面与图层更新流程一致，核心从getTargetsJson()说起，getTargetsJson()调用了getAllTargets()，在getAllTargets()中查询数据库并先将所有目标放到QList<QSqlRecord> records中，然后遍历records，获取不同类型目标的数量并调用getTarget(record)函数，将其返回值放入QList<Target *> tmp和一个键为id值为目标的QMap<qint64,Target*> mTargetMap中，其中getTarget(record)用来判断该目标是否已存在，若该目标之前没有则创建新的目标，若有则更新目标信息，不管怎样都会执行assign()，在assign()中更新目标信息并发送change()信号（至此与buildTargetConnection(target)中的change()对应上，即一旦change()则触发updateInfo()更新右侧目标信息）-->接着发送更新右侧总览信息的信号（前面已获取不同类型目标的数量）触发infodisplayrightWidget的updateEnemyAndOurselvesInfo()槽函数-->遍历targetMap的key，若有的已不存在则delete其value指针-->将本次查询的mTargetMap赋给targetMap，最后返回tmp以供map.html使用

#5月3日
###QTcpSocket的readyRead信号触发条件解释
https://blog.csdn.net/weixin_30697239/article/details/98031942?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.pc_relevant_default&utm_relevant_index=2

###127.0.0.1和0.0.0.0等特殊IP的区别
https://blog.csdn.net/weixin_36572983/article/details/108109725

#5月10日
1.五路视频线程变为六路。
2.增加天基，空基，地基，在线四个侦察信息传输接口，实现形式为界面下拉框，加载按钮（在线、离线切换未实现）。
3.目标和平台，态势刷新，新增和删除的目标增加提示信息（信息栏名称、信息栏图标、提示信息内容待定），高亮，闪烁。
4.二维地图右侧目标信息栏添加传感器类型、目标状态，置于“是否室内”的位置，“是否室内”放最下，目标状态实现显示。
5.了解在线地图存哪儿，可能存在C盘。

#5月11日
1.目标状态（完好、摧毁、不明）切换前端（entity.js）实现，具体图片未加。
2.了解als地图数据包加载的工作量，多级地图只发布最后一级就可。
3.传感器类型因不合理暂时去掉。
4.实现地图在线、离线切换（存在目标图层被遮盖问题）。

#5月12日
1.解决目标图层被遮盖问题。
2.提示信息不需要高亮、闪烁，添加时间提示即可。
3.二维三维联调（三维的目标类型需要调整，以我方二维地图的目标类型为准）。
具体目标类型为：（标红为本次出差主要显示的目标类型）
A 武装人员
B 坦克
C 小型旋翼无人机
D 防御工事
E 平民
F 装甲车
G 直升机
Q 通讯电台
P 障碍
R 未知
4.阿拉善tif格式地图由205总体找的绘制三维地图的单位提供。

#5月13日
1.解决二维地图上三维观测区域图层覆盖问题。
2.联系三维远程部署更改目标类型后的三维态势后台，制作阿拉善目标的sql文件，完成二三维地图联调，制作二三维联调截图文档（5张截图）。
3.二维地图障碍的图标暂用防御工事替代，目标身份的颜色待定。

#5月14日
1.制作障碍六张图标。
2.解决切换地图后无法隐藏地图图层的bug。

#5月16日
1.确定目标身份的颜色与不同目标类型的图标，联系三维修改目标身份的图标颜色。
A 敌方 蓝色
B 我方 红色
O 未知 黄色
2.制作摧毁和不明目标状态的样标。

#5月17日
1.联系三维修改前端。
2.不同目标状态的图标确定，并制作现有图标所有的目标状态，实现目标状态切换，制作信息栏图标。

#5月18日
1.制作显控文电发送前端。

#5月20日
1.二三维地图与指控地图对照目标的位置是否一致，并制作三维指控地图对照文档（5张截图）。
2.二维阿拉善tif地图须有关人员现场提供。

#5月21日
操作系统 1p

###ps修改图片中文字内容
多边形套索工具选中后右键选择填充（选中对应的图层不然填充是灰色），打开后选择内容识别，确定，然后删除再添加相应文字。

###ps将图片背景调为透明
魔棒工具-选择反向-通过拷贝的图层即可，换背景的话新建一个图层（填充颜色ALT+BACKSPACE使用前景色，CTRL+BACKSPACE使用的是背景色）将透明图层的图片放在新图层之上即可。

#5月22日
操作系统 2p 4p-7p

###用户程序与内核程序都在内存中，内核态可以访问任何数据，用户态不能访问内核数据

###系统调用背后是如何实现的？（如printf，open等是如何执行的）
用户调用printf-通过库函数printf展成int 0x80-中断处理，进入内核态-查表-调用sys_write
核心：
1.用户程序中包含一段包含int指令（中断指令）的代码
2.操作系统写中断处理，获取想调程序的编号
3.操作系统根据编号执行相应代码

#5月23日
操作系统 8p-9p

###多进程图像
让cpu跑一个进程，cpu就开始工作了，为了让cpu更加高效的工作，需要跑多个进程，交替的执行。

#5月26日
操作系统 10p

#5月29日
操作系统 11p

#6月4日
操作系统 13p-14p

###Windows10壁纸存储路径
C:\Users\lihdeng\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets

#9月26日

    <build>
        <plugins>
<!-- .original为可依赖的jar，在target目录，需修改mainClass-->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>cn.edu.xidian.authorization.AuthorizationApplication</mainClass>
                </configuration>
            </plugin>
        </plugins>
<!-- 打到maven仓库的jar以供依赖-->
        <plugins>
            <plugin>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.0.0</version>
            </plugin>
        </plugins>
    </build>

#10月14日
idea64.exe.vmoptions
-javaagent:C:\jetbrains-agent.jar
IDEA2021
https://www.jb51.net/article/196349.htm#_lab2_0_3

#11月24日
西电本科生、研究生、教职工信息查询：
https://dmp.xidian.edu.cn:8771/open_api/authentication/get_access_token?key=20221018744415823296532328038405662&secret="45460dc30488d5935a4db194a804cca6804b082f"
https://dmp.xidian.edu.cn:8771/open_api/customization/tgxxsyjsjbxx/list?access_token=fa89a7ce-97be-46fb-86d4-b4306c0bfcb1&XM=XXX

#11月25日
背包问题的理解（均为一维dp数组）
01背包
背包遍历需要倒着来，正着来会放入重复物品，并且要先遍历物品后遍历背包，不然背包里只会放入一种物品

完全背包
背包遍历正着来，先遍历物品后遍历背包是求组合（[1,2,1]与[1,1,2]是一种情况），先遍历背包后遍历物品是求排列（[1,2,1]与[1,1,2]是两种情况）
